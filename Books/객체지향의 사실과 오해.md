

# 객체지향의 사실과 오해

 이 책은 객체지향에 대해 이상한나라의 앨리스를 인용하여 설명하고 있습니다. 책을 읽으면 다양한 예시를 통해 객체지향 설계에 대해 이해 할 수 있습니다. 이 페이지는 앨리스와 관련된 인용을 제외한 요약 본임을 알려드립니다. 좀더 자세한 이해를 원하시면 책을 직접 읽어보시고 이 페이지는 참고용으로만 사용하세요^^*



### 목차

1. [협력하는 객체들의 공동체](#1-협력하는-객체들의-공동체)
2. [이상한 나라의 객체](#2-이상한-나라의-객체)
3. [타입의 추상화](#3-타입의-추상화)
4. [협력, 책임, 역할](#4-협력,-책임,-역할)
5. [책임과 메시지](#5-책임과-메세지)
6. [객체 지도](#6-객체-지도)
7. [함께 모으기](#7-함께-모으기)



## 1. 협력하는 객체들의 공동체



## 2. 이상한 나라의 객체

### 행동이 상태를 결정한다

* 상태를 결정하고 행동을 결정하는 설계는 나쁜 설계이다

  * 캡슐화를 저해한다
  * 협력체계가 아닌 고립된 객체로 생각하는 것이다.
  * 재사용성을 저해한다
* 객체는 다른 객체와 협력하기 위해 존재한다
* 협력은 책임이다(책임주의 계발 - RDD)



### 은유와 객체

* **객체지향 설계는 현실세계의 모방이 아니다.**
* 의인화
  * 객체들은 어떤일이라도 할 수있다. 
  * " 현실세계에서 카드는 뒤집힐 수 만 있지만, 소프트웨어 세상에서는 스스로 뒤집는다."

* 은유
  * 객체지향 설계는 현실에 대한 은유이다. 단순한 모방이 아니다.



## 3. 타입과 추상화

현실 세계의 지하철 노선도는 정확성(실제와 일치) 보다 목적성(출발지, 도착지, 환승지)에 따라 그려저있다. 이와 같은 개념이 추상화 이다.

### 추상화를 총한 복잡성 극복

진정한 추상화란 현실에서 출발하되 불필요한 부분을 도려내가면서 사물의 놀라운 본질을 드러내는 과정이다.



### 객체지향과 추상화

* **개념** : 객체들을 묶기위한 그릇
  * 여왕, 왕, 병사, 정원사는 트럼프라는 개념으로 묶을 수 있다.
* **인스턴스** : 객체에 어떤 개념을 적용하는 것이 가능해서 개념그룹의 일원이 될 때 객체를 그 개념의 인스턴스라 한다.
* 개념은 객체를 **분류**할 수 있는 틀을 제공한다.
* 개념의 세가지 관점
  * 심볼 : 개념을 가리키는 간략한 명칭
  * 내연 : 개념의 완전한 정의 / 개념을 객체에게 적용 할 수 있는지 여부를 판단
  * 외연 : 개념에 속하는 모든 객체의 집합



### 타입

* 타입은 개념이다.
* 타입은 데이터가 어떻게 사용되느냐에 관한것
* 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다.
* 객체 \= 타입
* 행동이 우선이다.
  * 객체가 어떻게 행동하느냐에 따라 객체의 타입을 정할 수 있다. / 어떤 데이트를 가지고 있는지에 따라 객체를 정의해서는 안된다.



### 타입의 계층

* 일반화 / 특수화
  * 타입과 타입사이에는 일반화/특수화 관계가 존재할 수 있다.
  * 일반화 : 포괄적 / 특수화 : 더 자세한
  * 두 타입사이의 일반화와 특수화 관계는 객체의 행동에 의해 결정된다.
  * 슈퍼타입 - 일반화 / 서브타입 - 특수화
  * 일반화가 더 넓은 개념이다.
* 객체를 분류하는 기준은 타입(개념)이며, 타입을 나누는 기준은 객체가 수행하는 행동이다.
* 객체를 구현하는 방법중 하나가 클래스이다.



## 4. 협력, 책임, 역할

중요한 것은 개별 객체가 아니라 객체들 사이에 이루어지는 협력관계이다.



### 협력

* 요청과 응답의 과정



### 책임

* 요청에 적절한 행동을 대답
* 책임의 분류
  * 아는 것
  * 하는 것
* 책임과 메세지
  * 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것 -> 메세지 전송
  * 협력을 위해 객체끼리 접근할 수 있는 유일한 방법이 메세지를 보내는 것이다.
  * 책임과 메세지 수준은 같지 않다
    * 하나의 책임이 여러개의 메세지를 분할 되는 것이 일반적
    * 설계 초반에는 책임만 확실히 하고, 메세지는 나중에 



### 역할

* 책임의 집합을 의미한다
* 역할은 객체를 재사용 가능하게 하며, 유연하다 -> 역할로 추상화가 가능하다.
* 동일한 역할을 수행 할 수 있다. -> 협력내에서 동일한 책임의 집합을 수행할 수 있다.
* 역할의 개념을 사용하면 협력을 추상화 할 수있다.
* 다양한 객체들이 협력에 참여할 수 있어 유연성이 높으며 재사용 가능하다
* 협력의 추상화
  * 역할 : 협력내에서 여러종류의 객체가 찹여할 수 있게 함으로써 협력을 추상화 할 수 있다.
  * 대체가능성 : 역할을 다양한 객체가 수행 -> 호환가능성 / 모든 책임을 동일하게



### 객체의 모양을 결정하는 협력

### 객체지향 설계

* 책임주도
* 디자인패턴 - GoF 디자인패턴
* 테스트주도



# 5. 책임과 메세지

책임과 역할을 명확히 해야 한다.



### 자율적인 책임 

* 책임은 너무 구체적이거나 혹은 너무 추상적이면 안된다.

*  어떤 메세지를 받으면 그 명령에 따라 자율적으로 응답한다.



### 메시지와 메서드

* 메시지 : 하나의 객체는 메시지를 전달 함으로써 다른 객체에 접근한다.

  * 메세지는 수신자 메시지 인자의 나열이다.
  * 송신자는 수신자가 어떻게 메시지를 어떻게 처리하는지 알 수 없다.
* 메서드 : 수신할 메시지와 처리하기 위해 선택할 수 있는 방법 

  * 메시지를 처리하기 위해 내부적으로 선택하는 방법이 메서드이다.
  * 메서드는 클래스 안에 포함된 함수 또는 프로시저로 구현한다.
* 어떻게 수행될 것인가 가 아닌 무엇을 수행할 것인가.

  * 어떤 메서드를 선택할지는 전적으로 수신자가 선택한다.
  * 실행시간에 선택할 수 있다는 것은 객체지향언어의 특징이다.
* 다형성

  * 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것
  * 협력을 유연하게 만든다.
  * 재사용성이 높다.
* 유연하고 확장가능하며 재사용성이 높다는 협력의 의미
  * 유연하다: 송신자는 수신자가 메시지를 이해한다면 누구든 상관 없다.
  * 협력이 숭행되는 방식의 확장 : 송신자에 영향받지 않는다. 수신자는 교체가 가능하다. 메서드는 변경이 가능하다.
  * 재사용성이 높다.



### 메시지를 따라라

* 객체지향의 핵심, 메시지
  * 객체지향의 강력함은 클래스가 아니라 객체들이 주고받는 메시지로부터 나온다.
  * 클래스는 동적인 객체들의 추상화 도구일 뿐이다.
  * 객체자체에 초점을 맞추면 문맥을 배제하게 된다.
  * 내부 데이터 구조를 먼저 생각하고 오퍼레이션을 나중에 생각하는 설계는 좋지않다.
* What/Who 사이클
  * 협력에 참여할 객체를 찾기 전에 메시지를 먼저 생각하라 -> 인터페이스의 발견



### 객체 인터페이스

**인터페이스** : 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치

1. 사용법만 익히면 내부구조나 동작방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.
2. 단순히 내부구성이나 작동방식만 변경하는 것은 사용자에게 어떤 영향도 미치지 않는다
3. 대상이 변경되더라도 동일한 인터페이스를 제공하기만하면 아무런 문제 없이 상호작용 할 수 있다.

* 메시지가 인터페이스를 결정한다
* 공용인터페이스 <-> 내부에만 공개된 인터페이스
* 객체의 이너페이스는 수신할 수 있는 메시지 목록으로 채워진다. 객체는 메시지를 수신했을 때 적절한 객체의 책임이 수행된다 . 메서드란 메시지를 수신했을 때 책임을 수행하는 방법을 의미한다.
* 메세지와 메서드는 다형성을 통해 다양한 객체를 수용할 수 있는 유연성을 부과한다.



### 인터페이스와 구현의 분리

* 객체 관점에서 생각하는 방법
  * 좀 더 추상적인 인터페이스
  * 최소 인터페이스
  * 인터페이스와 구현간에 차이가 있다는 것을 인식
* 구현 : 외부 궁용인터페이스 이외의  내부적인 것 모두를 구현이라 한다.
* 인터페이스와 구현의 분리 원칙
  * 객체지향설계의 핵심 => 외부에 공개된 인터페이스와 내부에 감춰진 구현을 분리해 설계하는 것이다.
  * 소프트웨어는 변경가능성이 있기 때문이다.
  * 내부 메서드와 상태를 수정하더라도 외부에 영향을 미치지 않는다.
* 캡슐화 : 구현을 외부로부터 감추는 것 = 정보은닉
  * 상태와 행위는 캡슐화
    * 데이터의 캡슐화를 의미한다.
  * 사적인 비밀의 캡슐화
* **객체지향은 내부와 외부를 명확하게 구분하는 객체들로 구성된 협력공동체이다.**



### 책임의 자율성이 협력의 품질을 결정한다.

변경하기 쉽고 유연한 협력 / 자율적일수록 협력 가능성과 변경 유연성이크다.

1. 협력을 단순하게 만든다.
2. 외부와 내부를 명확하게 한다.
3. 내부가 변경되더라도 외부에 영향을 미치지 않는다.
4. 협력의 대상을 다양하게 선택할 수 있는 유연성
5. 객체의 역할을 이해하기 쉬워진다.



## 6. 객체 지도

 길을 찾을 때 2가지 방법이 있다. 주변사람에게 묻는 것과 지도를 보는 것. 주변사람에게 길을 묻는 다면 사거리에서 좌회전해서 100m를 가세요 처럼 기능 중심이다. 반면 지도를 보고 길을 찾는 것은 구조적이다. 구조적인 지도를 기반으로 길을 찾는다면, 변경에 용의 하다. 이번장은 자주 변경되느 기능이 아니라 안정적인 구조에 따라 역할, 책임, 협력을 구성하는 방법에 관한 것이다.



### 기능 설계 대 구조 설계

 소프트웨어 설계는 기능 설계와 구조 설계로 나눠질 수 있다. 설계의 가장 큰 도전은 기능과 구조라는 두 가지 측명을 함께 녹여 조화를 이루도록 만드는 것이다.

 실제세계에서는 요구사항이 변경된다. 훌륭한 설계자가 되기위해서는 좋은 기능과 함께 변경에 유연하게 대처할 수 있는 안정적인 구조를 제공하는 능력이다.

 기능 위주의 설계는 변경에 취약하기 때문에 구조 위주의 설계를 하는 것이 좋다.

### 두가지 재료: 기능과 구조

기능: 사용자가 자신의 목표를 달성하기 위해 사용할 수 있는 시스템의 서비스

 구조: 시스쳄의 기능을 구현하기 위한 기반으로, 기능 변경을 수용할 수 있도록 안정적이어야 한다.

* 구조는 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들 간의 관계를 표현한다.

* 기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현한다.

 기능을 수집하고 표현하기 위한 기법은 유스케이스 모델링, 구조를 수집하고 표현하기 위한 기법을 도메인 모델링 이라고 한다.



### 안정적인 재료: 구조

* 도메인 모델
  * 사용자가 프로그램을 사용하는 대상 분야를 도메인이라고 한다.
  * 도메인 모델이란 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태이다.
  * 멘탈 모델이란 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형이다. 소프트웨어 사용자들 역시 도메인에 존재하는 현상을 이해하고 현상에 반응하기 위해 도메인과 관련된 멘탈 모델을 형성한다.
  * 메탈모델은 사용자 모델, 디자인 모델, 시스템 이미지로 구분 한다.
* 도메인의 모습을 담을 수 있는 개체 지향
  * 객체지향을 이용하면 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지가 모두 유사한 모습으로 만들 수 있다.
* 표현의 차이
  * 소프트웨어 세계는 현실을 은유를 기반으로 재창조하는 것이다. 왜곡이 발생하더라도 현실 객체의 특성을 토대로 구축된 것이다. 이처럼 두 현실과 소프트웨어 객체 사이의 의미적 기르를 가리켜 표현적 차이 또는 의미적 차이라 한다. **핵심을 이를 줄이는 것이다**
* 불안정한 기능을 담는 안정적인 도메인 모델
  * 안정적인 구조를 제공하는 도메인 모델을 기반으로 소프트웨어의 구조를 설계하면 변경에 유연하게 대응할 수 있는 탄력적인 소프트웨어를 만들 수 있다.



### 불안정한 재료: 기능

* 유스케이스 : 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것을 유스케이스라고 한다.
* 유스케이스의 특성
  * 유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 텍스트이다. 다이어그램이 아닌 이야기에 집중하라
  * 유스케이스는 하나의 시나리오가 아니라 여러 시나리오의 집합이다. 
  * 유스케이스는 단순한 피처 목록과는 다르다.  단순히 기능을 나열한 것이 아니라 이야기를 통해 연관된 기능들을 함께 묶을 수 있다.
  * 유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다. 
  * 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다.
* 유스케이스는 설계 기법도, 객체지향 기법도 아니다.
  * 유스케이스는 단지 사용자가 시스템을 통해 무엇을 얻을 수 있고 어떻게 상호작용할 수 있느냐에 관한 정보만 기술된다. 유스케이스는 단지 기능적 요구사항을 사용자의 목표라는 문맥을 중심으로 묶기 위한 정리 기법일 뿐이다. Structuring Use Cases With Goals



### 재료 합치기: 기능과 구조의 통합

* 도메인 모델, 유스케이스, 그리고 책임-주도 설계
  * 변경에 유연한 소프트웨어를 만들기 위해서는 유스케이스에 정리된 시스템의 기능을 도메인 모델을 기반으로 한 객체들의 채임으로 분배해야 한다.
  * 시스템의 사용자의 메시지는 수행하며 협력하는 거대한 객체이다. 시스템 안에는 더 작은 객체들이 있다.
  * 객체지향 설계는 다음과 같이 설명되기도 한다.
    * 요구사항들을 식별하고 도메인 모델을 생성한 후, 소프트웨어 클래스에 메서드들을 추가하고, 요구사항을 충족시키기 위해 객체들 간의 메시지 전송을 정의하라.
  * 책임주도 설계는 유스케이스로부터 첫 번째 메시지와 사용자가 달성하려는 목표를, 도메인 모델로부터 기능을 수용할 수 있는 안정적인 구조를 제공받아 실제로 동작하는 객체들의 협력 공동체를 창조한다.

## 7. 함께 모으기

* 마티 파울러의 객체지향 설계안에 존재하는 3가지 관점
  * 개념 관점 - 도메인 안에 존재하는 개념과 개념 사이의 관계
  * 명세 관점 - 도메인 관점이 아니라 소프트웨어 관점. 객체들의 책임에 초점
  * 구현 관점 - 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것
  * 개념 관점, 명세 관점, 구현 관점은 동일한 클래스를 세가지 다른 방향으로 ㅂ바라보는 것을 의미한다.