# 클린코드

**클린코드 애자일 소프트웨어 장인 정신**(로버트 C.마틴 | 박재호,이해영 옮김)

 이 페이지는 책에 대한 주관적인 해석과 요약이 되어있으니 참고하시기 바랍니다. 큰 목차는 모두 작성하였지만 세부 목차는 필요에 따라 뺀 경우도 있습니다. 책의 내용을 그대로 실었을 경우에는 인용 기호를 사용하였습니다. 그 이외는 주관적인 생각이 들어있을 수 있음을 알려드립니다. 좀 더 자세한 내용을 원하시는 분은 꼭 원책을 읽어보시길 추천드립니다.



## 목차

1. [깨끗한 코드](#1장-깨끗한-코드)
2. [의미 있는 이름](2장-의미-있는-이름)
3. [함수]()
4. [주석]()
5. [형식 맞추기]()
6. [객체와 자료구조]()
7. [오류 처리]()
8. [경계]()
9. [단위 테스트]()
10. [클래스]()
11. [시스템]()
12. [창발성]()
13. [동시성]()
14. [점진적인 개선]()
15. [JUnit 들여다보기]()
16. [SerialDate 리팩터링]()
17. [냄새와 휴리스틱]()



## 들어가면서

> 장인 정신을 익히는 과정은 두 단계로나뉘다. 바로 이론과 실전이다. 첫째, 장인에게 필요한 원칙, 패턴, 기법, 경험이라는 지식을 습득해야 한다. 둘째, 열심히 일하고 연습해 지식을 몸과 마음으로 체득해야 한다.

 아무리 열심히 자전거 타는 이론을 100% 이해했다 하더라도 실제 자전거를 타보면 모든 사람이 넘어진다. 지식을 습득했다면 몸으로 익히는 과정을 거쳐라. 





## 1장 깨끗한 코드

### 코드가 존재하리라

> 코드가 사라질 가망은 전혀 없다. 코드는 요구사항을 상세히 표현하는 수단이다. 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세하게 표현할 수 없다.



### 나쁜코드

> 나쁜 코드를 작성하고, 나중에 손보겠다고 하지만 나중은 없다. 



### 나쁜 코드로 치르는 대가

나쁜코드가 쌓일수록 팀 생산성은 떨어진다.

* 원대한 재설계의 꿈
  * 기존 프로그램을 재설계하는 일은 기존 설계에 추가되는  코드와 기존코드를 다시 설계해야하는 고비용의 작업이다.
* 태도
  * 작업환경이나, 마감일, 상사의 요구등의 환경때문에 나쁜 코드를 작성한다고 핑계를 대지만 책임은 그 코드를 작성한 프로그래머에게 있다.
* 원초적 난제
  * 깨끗한 코드를 작성하는 일은 시간이 많이 드는 일인 것 같지만, 나쁜코드는 시간을 더 늦출 뿐이다.
* 깨끗한 코드란
  * 비야네 스트롭스트룹 : 우아하고 효율적인 코드
  * 그래디 부치 : 단순하고 직접적이다.
  * 큰 데이브 토마스 : 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.
  * 마이클 페더스 : 언제나 누군가 주의 깊게 짰다는 느낌을 준다.
  * 론 제프리스: 중복을 피하라. 한기능만 수행하라. 제대로 표현하라. 작게 추상화하라.
  * 워드 커닝햄: 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.





## 2장 의미 있는 이름

### 의도를 분명히 밝혀라

> 변수나 함수 그리고 클래스 이름은 다음과 같은 굵직한 질문에 모두 답해야 한다. 변수(혹은 함수나 클래스)의 존재 이유는? 수행 기능은? 사용 방법은? 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다.



다음 코드는 읽기 편한 코드이고 컴파일에 문제는 없지만, 무엇을 의미하는 지 알 수 없다.

```java
public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<int[]>();
    for (int[] x : theList)
         if(x[0] == 4)
              list1.add(x);
    return list;
}
```



1. theList에 무엇이 들었는가?
2. theList에서 0번째 값이 어째서 중요한가?
3. 값 4는 무슨 의미인가?
4. 함수가 반환하는 리스트 list1을 어떻게 사용하는가?

 

다음 코드는 지뢰찾기 게임에 사용되는 코드이다.

```
public List<int[]> getFlaggedCells() {
    List<int[]> flaggedCells = new ArrayList<int[]>();
    for (int[] cell : gameBoard)
         if(x[STATUS_VALUE] == FLAGGED)
              flaggedCells.add(cell);
    return flaggedCells;
}
```

단순하게 이름만 고쳤는데도 함수가 하는 일을 이해하기 쉬워졌다.



### 그릇된 정보를 피하라

* 여러 계정을 그룹으로 묶을 때, 실제 list가 아니라면, accoutList는 잘못된 정보이다. -> accountGroup, bunchOfAccounts, Accounts가 더 적적할 명명이다.
* 흡사한 이름을 사용하지 않도록 주의한다.
* 유사한 개념은 유사한 표기법을 사용한다.



### 의미 있게 구분하라

```java
public static void copyChars(char a1[], char a2[]){
    for (int 1 =0; i < a1.length; i++){
        a2[i] = a1[i];
    }
}
```

다음 같은 코드도 a,b,c, a1, a2, a3 이름 보다도 source, destination을 사용한다면 코드 읽기가 훨씬 더 쉬워진다.



### 발음하기 쉬운 이름을 사용하라

코드 리뷰를 할 때 발음하기 어려운 이름이랄지, 웃긴이름의 변수, 메소드, 클래스를 생각해보라..



### 검색하기 쉬운 이름을 사용하라

 IDE는 코딩을 편하게 해주는 도구이다. 이 기능을 이용하여 검색하기 좋은 이름을 사용하라.



### 해법 영역에서 가져온 이름을 사용하라

 코드를 작성하는 사람이 이해하기 쉬운 전산용어, 알고리즘 이름, 패턴이름, 수학이름등을 사용하면 좋다.



## 문제 영역에서 가져온 이름을 사용하라

 적절한 프로그램 용어가 없다면 프로그래머가 분야 전문가에게 의미를 물어 파악할 수 있는 이름을 사용하라



### 의미 있는 맥락을 추가하라

 스스로 의미가 분명한 이름이 없지 않지만 어렵다. 모든 방법이 실패한다면 접두어를 붙인다.

 firstName, lastName, street, houseNumber, city, state, zipcode라는 변수가 있다. 이를 한번에 훑어보면 주소라는 것을 알 주 있지만 stree 변수 하나만 있다면 주소인지 알기 쉽지 않다.  이럴때 addr라는 접두어를 추가하라. 물론 Address라는 클래스를 생성하면 더 좋다.



```java
private void printGuessStatistics(char candidate, int count) {
	String number;
	String verb;
	String pluralModifier;
    
    if(count == 0){
        number = "no";
        verb = "are";
        pluralModifier = "s";
    } else if(count == 1){
        number = "1";
        verb = "is";
        pluralModifier = "";
    }else{
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }
    
    String guessMessage = String.format(
        "There %s %S %s%s", verb, number, candidate, pluralModifier
    );
    print(guessMessage);
}
```

세 변수가 어디에 사용되는 맥락을 알 수 없다. 전체적인 메소드를 이해해야 GuessStatistics에 사용됨을 알 수 있다.



```java
public class GuessStatisticsMessgae{
    private String number;
    private String verb;
    private String pluralModifier;
    
    public String make(char candidate, in count){
        createPluralDependentMessagePars(count);
        return String.format(
        	"There %s %S %s%s", verb, number, candidate, pluralModifier
        )
    }
    
    private void createpluralDependentMessagePart(int count){
        if(count == 0){
            thereAreNoLetters();
    	} else if(count == 1){
            thereIsOneLetter();
    	}else{
            thereAreManyLetters(count);
    	}
    }
    
    private void thereAreManyLetters(int count){
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }
    
    private void thereIsOneLetter(){
        number = "1";
        verb = "is";
        pluralModifier = "";
    }
    
    private void thereAreNoLetters(){
        number = "no";
        verb = "are";
        pluralModifier = "s";
    }
}
```

